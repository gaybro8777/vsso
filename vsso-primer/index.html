<!DOCTYPE html><html lang="en" dir="ltr"><head>
<meta charset="utf-8">
<meta name="generator" content="ReSpec 28.2.0">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<style>
dfn{cursor:pointer}
.dfn-panel{position:absolute;z-index:35;min-width:300px;max-width:500px;padding:.5em .75em;margin-top:.6em;font:small Helvetica Neue,sans-serif,Droid Sans Fallback;background:#fff;color:#000;box-shadow:0 1em 3em -.4em rgba(0,0,0,.3),0 0 1px 1px rgba(0,0,0,.05);border-radius:2px}
.dfn-panel:not(.docked)>.caret{position:absolute;top:-9px}
.dfn-panel:not(.docked)>.caret::after,.dfn-panel:not(.docked)>.caret::before{content:"";position:absolute;border:10px solid transparent;border-top:0;border-bottom:10px solid #fff;top:0}
.dfn-panel:not(.docked)>.caret::before{border-bottom:9px solid #a2a9b1}
.dfn-panel *{margin:0}
.dfn-panel b{display:block;color:#000;margin-top:.25em}
.dfn-panel ul a[href]{color:#333}
.dfn-panel>div{display:flex}
.dfn-panel a.self-link{font-weight:700;margin-right:auto}
.dfn-panel .marker{padding:.1em;margin-left:.5em;border-radius:.2em;text-align:center;white-space:nowrap;font-size:90%;color:#040b1c}
.dfn-panel .marker.dfn-exported{background:#d1edfd;box-shadow:0 0 0 .125em #1ca5f940}
.dfn-panel .marker.idl-block{background:#8ccbf2;box-shadow:0 0 0 .125em #0670b161}
.dfn-panel a:not(:hover){text-decoration:none!important;border-bottom:none!important}
.dfn-panel a[href]:hover{border-bottom-width:1px}
.dfn-panel ul{padding:0}
.dfn-panel li{margin-left:1em}
.dfn-panel.docked{position:fixed;left:.5em;top:unset;bottom:2em;margin:0 auto;max-width:calc(100vw - .75em * 2 - .5em - .2em * 2);max-height:30vh;overflow:auto}
</style>
    
    
    
  
<style id="respec-mainstyle">
@keyframes pop{
0%{transform:scale(1,1)}
25%{transform:scale(1.25,1.25);opacity:.75}
100%{transform:scale(1,1)}
}
:is(h1,h2,h3,h4,h5,h6,a) abbr{border:none}
dfn{font-weight:700}
a.internalDFN{color:inherit;border-bottom:1px solid #99c;text-decoration:none}
a.externalDFN{color:inherit;border-bottom:1px dotted #ccc;text-decoration:none}
a.bibref{text-decoration:none}
.respec-offending-element:target{animation:pop .25s ease-in-out 0s 1}
.respec-offending-element,a[href].respec-offending-element{text-decoration:red wavy underline}
@supports not (text-decoration:red wavy underline){
.respec-offending-element:not(pre){display:inline-block}
.respec-offending-element{background:url(data:image/gif;base64,R0lGODdhBAADAPEAANv///8AAP///wAAACwAAAAABAADAEACBZQjmIAFADs=) bottom repeat-x}
}
#references :target{background:#eaf3ff;animation:pop .4s ease-in-out 0s 1}
cite .bibref{font-style:normal}
code{color:#c63501}
th code{color:inherit}
a[href].orcid{padding-left:4px;padding-right:4px}
a[href].orcid>svg{margin-bottom:-2px}
.toc a,.tof a{text-decoration:none}
a .figno,a .secno{color:#000}
ol.tof,ul.tof{list-style:none outside none}
.caption{margin-top:.5em;font-style:italic}
table.simple{border-spacing:0;border-collapse:collapse;border-bottom:3px solid #005a9c}
.simple th{background:#005a9c;color:#fff;padding:3px 5px;text-align:left}
.simple th a{color:#fff;padding:3px 5px;text-align:left}
.simple th[scope=row]{background:inherit;color:inherit;border-top:1px solid #ddd}
.simple td{padding:3px 10px;border-top:1px solid #ddd}
.simple tr:nth-child(even){background:#f0f6ff}
.section dd>p:first-child{margin-top:0}
.section dd>p:last-child{margin-bottom:0}
.section dd{margin-bottom:1em}
.section dl.attrs dd,.section dl.eldef dd{margin-bottom:0}
#issue-summary>ul{column-count:2}
#issue-summary li{list-style:none;display:inline-block}
details.respec-tests-details{margin-left:1em;display:inline-block;vertical-align:top}
details.respec-tests-details>*{padding-right:2em}
details.respec-tests-details[open]{z-index:999999;position:absolute;border:thin solid #cad3e2;border-radius:.3em;background-color:#fff;padding-bottom:.5em}
details.respec-tests-details[open]>summary{border-bottom:thin solid #cad3e2;padding-left:1em;margin-bottom:1em;line-height:2em}
details.respec-tests-details>ul{width:100%;margin-top:-.3em}
details.respec-tests-details>li{padding-left:1em}
a[href].self-link:hover{opacity:1;text-decoration:none;background-color:transparent}
h2,h3,h4,h5,h6{position:relative}
aside.example .marker>a.self-link{color:inherit}
:is(h2,h3,h4,h5,h6)>a.self-link{border:none;color:inherit;font-size:83%;height:2em;left:-1.6em;opacity:.5;position:absolute;text-align:center;text-decoration:none;top:0;transition:opacity .2s;width:2em}
:is(h2,h3,h4,h5,h6)>a.self-link::before{content:"§";display:block}
@media (max-width:767px){
dd{margin-left:0}
:is(h2,h3,h4,h5,h6)>a.self-link{left:auto;top:auto}
}
@media print{
.removeOnSave{display:none}
}
</style>
<title>VSSo: Vehicle Signal Specification Ontology Primer</title>
<meta name="description" content="The challenges around the existing variance of describing and working with 
        vehicle data has motivated contributors from the automotive industry to 
        develop and maintain the so-called Vehicle Signal Specification. 
        As the semantics of the specification are limited to a tree-like hierarchy and data types, 
        it has been considered for the foundation of a more expressive model resulting into the
        Vehicle Signal Specification Ontology (VSSo). This document shall give an overview
        of the use cases and structure of the ontology.">
<style>
var{position:relative;cursor:pointer}
var[data-type]::after,var[data-type]::before{position:absolute;left:50%;top:-6px;opacity:0;transition:opacity .4s;pointer-events:none}
var[data-type]::before{content:"";transform:translateX(-50%);border-width:4px 6px 0 6px;border-style:solid;border-color:transparent;border-top-color:#000}
var[data-type]::after{content:attr(data-type);transform:translateX(-50%) translateY(-100%);background:#000;text-align:center;font-family:"Dank Mono","Fira Code",monospace;font-style:normal;padding:6px;border-radius:3px;color:#daca88;text-indent:0;font-weight:400}
var[data-type]:hover::after,var[data-type]:hover::before{opacity:1}
</style>
<script id="initialUserConfig" type="application/json">{
  "group": "autowebplatform",
  "specStatus": "unofficial",
  "editors": [
    {
      "name": "Daniel Wilms",
      "url": "https://www.linkedin.com/in/danielwilms/"
    }
  ],
  "github": {
    "branch": "main",
    "repoURL": "w3c/vsso"
  },
  "publishISODate": "2022-01-16T00:00:00.000Z",
  "generatedSubtitle": "Unofficial Draft 16 January 2022"
}</script>
<link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/2021/W3C-UD"></head>
  <body class="h-entry informative"><div class="head">
     <h1 id="title" class="title">VSSo: Vehicle Signal Specification Ontology Primer</h1>
    
    <p id="w3c-state">Unofficial Draft <time class="dt-published" datetime="2022-01-16">16 January 2022</time></p>
    <details open="">
      <summary>More details about this document</summary>
      <dl>
        
        <dt>Latest editor's draft:</dt><dd><a href="https://w3c.github.io/vsso/">https://w3c.github.io/vsso/</a></dd>
        <dt>History:</dt><dd>
        <a href="https://github.com/w3c/vsso/commits/main">Commit history</a>
      </dd>
        
        
        
        
        
        <dt>Editor:</dt>
        <dd class="editor p-author h-card vcard">
    <a class="u-url url p-name fn" href="https://www.linkedin.com/in/danielwilms/">Daniel Wilms</a>
  </dd>
        
        
        <dt>Feedback:</dt><dd>
        <a href="https://github.com/w3c/vsso/">GitHub w3c/vsso</a>
        (<a href="https://github.com/w3c/vsso/pulls/">pull requests</a>,
        <a href="https://github.com/w3c/vsso/issues/new/choose">new issue</a>,
        <a href="https://github.com/w3c/vsso/issues/">open issues</a>)
      </dd>
        
        
      </dl>
    </details>
    
    
    <p class="copyright">
      Copyright ©
      2022
      the document editors/authors.
      Text is available under the
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/legalcode">Creative Commons Attribution 4.0 International Public License</a>; additional terms may apply.
    </p>
    <hr title="Separator for header">
  </div> 
    
    <section id="abstract" class="introductory"><h2 id="abstract-0">Abstract<a class="self-link" href="#abstract" aria-label="Permalink for Section"></a></h2>
      <p align="justify">
        The challenges around the existing variance of describing and working with 
        vehicle data has motivated contributors from the automotive industry to 
        develop and maintain the so-called Vehicle Signal Specification. 
        As the semantics of the specification are limited to a tree-like hierarchy and data types, 
        it has been considered for the foundation of a more expressive model resulting into the
        Vehicle Signal Specification Ontology (VSSo). This document shall give an overview
        of the use cases and structure of the ontology. 
      </p>
    </section>
    <section id="sotd" class="introductory"><h2 id="status-of-this-document">Status of This Document<a class="self-link" href="#sotd" aria-label="Permalink for Section"></a></h2><p>
      This document is a draft of a potential specification. It has no official
      standing of any kind and does not represent the support or consensus of
      any standards organization.
    </p>
      
    </section><nav id="toc"><h2 class="introductory" id="table-of-contents">Table of Contents</h2><ol class="toc"><li class="tocline"><a class="tocxref" href="#abstract">Abstract</a></li><li class="tocline"><a class="tocxref" href="#sotd">Status of This Document</a></li><li class="tocline"><a class="tocxref" href="#introduction"><bdi class="secno">1. </bdi>Introduction</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#vehicle-signal-specification-vss"><bdi class="secno">1.1 </bdi>Vehicle Signal Specification (VSS)</a></li></ol></li><li class="tocline"><a class="tocxref" href="#use-cases"><bdi class="secno">2. </bdi>Use Cases</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#current-vehicle-data"><bdi class="secno">2.1 </bdi>Current Vehicle Data</a></li><li class="tocline"><a class="tocxref" href="#dynamic-vehicle-data-over-time"><bdi class="secno">2.2 </bdi>Dynamic Vehicle Data over Time</a></li><li class="tocline"><a class="tocxref" href="#interaction-with-vehicle-data"><bdi class="secno">2.3 </bdi>Interaction with Vehicle Data</a></li></ol></li><li class="tocline"><a class="tocxref" href="#structure"><bdi class="secno">3. </bdi>Structure</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#vsso-core"><bdi class="secno">3.1 </bdi>VSSo Core</a></li><li class="tocline"><a class="tocxref" href="#vsso"><bdi class="secno">3.2 </bdi>VSSo</a></li><li class="tocline"><a class="tocxref" href="#extensions"><bdi class="secno">3.3 </bdi>Extensions</a></li></ol></li></ol></nav>
    <section data-dfn-for="intro" id="introduction">
      <h2 id="x1-introduction"><bdi class="secno">1. </bdi>Introduction<a class="self-link" href="#introduction" aria-label="Permalink for Section 1."></a></h2>
        <p align="justify">
          The goal of this ontology is to provide a reusable model for describing and interacting 
          with vehicle data. It relies on the existing Vehicle Signal Specification (VSS), lifting 
          it to more expressive semantics. As depicted below, the ontology serves as a domain ontology
          for observations, streams or service interactions.
        </p>
        <section id="vehicle-signal-specification-vss">
          <h3 id="x1-1-vehicle-signal-specification-vss"><bdi class="secno">1.1 </bdi>Vehicle Signal Specification (VSS)<a class="self-link" href="#vehicle-signal-specification-vss" aria-label="Permalink for Section 1.1"></a></h3>
          <p align="justify">
            VSS started in 2016 as a project of the GENIVI Alliance aiming at standardizing 
            vehicle signals and attributes. The specification consists of a data model defined in YAML.
            As shown in the figure below, it resembles a tree structure - not in a sense of a taxonomy,
            but rather categorization with a part of relationship from the vehicle as a root node to the
            signals in the leaves. The structure and content is actively worked on and evolves over time. 
            VSS also includes tools that offer serializations in multiple formats (e.g. CSV or JSON).
          </p>

          <figure id="figure-vss">
            <img src="static/vss_basic_tree.png" alt="VSS tree" height="566" width="1021">
            <figcaption>Figure <bdi class="figno">1</bdi> <span class="fig-title">Basic tree structure of VSS</span></figcaption>
          </figure>

          <p align="justify">
            As VSS comes with a proprietary rule set for the concept definition, VSS falls short, when it
            comes to connecting signals with other domains. 
          </p>
        </section>
    </section>
    <section id="use-cases">
      <h2 id="x2-use-cases"><bdi class="secno">2. </bdi>Use Cases<a class="self-link" href="#use-cases" aria-label="Permalink for Section 2."></a></h2>
      <p align="justify">
        Goal of VSSo is to be easily accessible and applicable in three different use cases that 
        are clustered into Analytics and Services. The former enables queries about the vehicle's 
        current data or data streams, whereas the latter enables the interaction between other 
        Things and vehicle data.
      </p>
        <figure id="figure-vsso-uc">
          <img src="static/vsso_use_cases.png" alt="VSS use cases" height="899" width="1601">
          <figcaption>Figure <bdi class="figno">2</bdi> <span class="fig-title">Envisioned Use Cases for VSSo</span></figcaption>
        </figure>  
        <section id="current-vehicle-data">
          <h3 id="x2-1-current-vehicle-data"><bdi class="secno">2.1 </bdi>Current Vehicle Data<a class="self-link" href="#current-vehicle-data" aria-label="Permalink for Section 2.1"></a></h3>
          <p align="justify">
            The core of the ontology is the description of vehicle attributes and signals. 
            From the modeling perspective, we refer to an attribute as a StaticVehicleProperty,
            that has information about a particular characteristic of the vehicle (e.g. fuel type, brand, etc.).
            In contrast, we refer to a signal as a DynamicVehicleProperty that is continuously changing 
            over time (e.g. speed, the status of a switch, etc.). Querying such properties' values from a vehicle 
            or finding similarities over a vehicle's fleet is a prominent use case.
            Let us consider the situation in which the customer wants to remotely see the current status of the 
            vehicle (e.g. door lock, window status, battery status, etc.). If the customer has more than one vehicle 
            in his account, all should be shown. Alternatively, an alarm should be triggered if the doors are locked 
            but the window is open. In all of those cases, a specific value is queried for one or a group of vehicles.
          </p>
        </section>
        <section id="dynamic-vehicle-data-over-time">
          <h3 id="x2-2-dynamic-vehicle-data-over-time"><bdi class="secno">2.2 </bdi>Dynamic Vehicle Data over Time<a class="self-link" href="#dynamic-vehicle-data-over-time" aria-label="Permalink for Section 2.2"></a></h3>
          <p align="justify">
            Another use case is the analysis of dynamic properties over time. Working with the data's streaming-nature 
            is important in situations where dynamic properties' behavior is essential for further analysis 
            (e.g. traffic prediction). Expressing the meaning of data streams requires concepts in the model 
            that refers to sequences and not only isolated observations. It is not realized with the core of 
            the ontology, but instead, it should contribute the domain knowledge to other ontologies (e.g. SOSA, IoTStream). 
            Aggregating dynamic data with high-level concepts help to perform data integration at the edge 
            and facilitates cross-applications interactions.
          </p>
        </section>
        <section id="interaction-with-vehicle-data">
          <h3 id="x2-3-interaction-with-vehicle-data"><bdi class="secno">2.3 </bdi>Interaction with Vehicle Data<a class="self-link" href="#interaction-with-vehicle-data" aria-label="Permalink for Section 2.3"></a></h3>
          <p align="justify">
            The Web of Things Working Group in the W3C develops various protocol and security schemes to 
            describe a device's accessible capabilities and data access. In this sense a vehicle can be 
            seen as a semantic web thing. In this case, the proposed ontology would add the domain knowledge 
            to a well-defined standard.
          </p>
        </section>
        
    </section>
    <section id="structure">
      <h2 id="x3-structure"><bdi class="secno">3. </bdi>Structure<a class="self-link" href="#structure" aria-label="Permalink for Section 3."></a></h2>
      <p align="justify">
        The structure of the ontology reflects the rules and standard catalogue used and defined in VSS.
        The rules define the supported kind of nodes (e.g. attributes, signals) and the format of their metadata 
        (e.g. units, datatypes). The standard catalogue uses those rules to define the semantics of the
        vehicle signals and attributes. A set of tools is then used to serialize the standard catalogue
        into the desired format (e.g. json, csv, proto, etc.).
      </p>

      <figure id="figure-vsso-uc">
        <img src="static/vsso_structure.png" alt="VSSo Structure" height="810" width="1062">
        <figcaption>Figure <bdi class="figno">3</bdi> <span class="fig-title">Structure and components of VSSo</span></figcaption>
      </figure> 
      
      <p align="justify">
        As the nature of the rule set and overall component structure in terms of update frequency and reusability
        is quite different from the standard catalogue, the ontology is split into:
          </p><ul>
            <li>
              <b>VSSo Core</b> - defining the structural building blocks of VSS.
            </li>
            <li>
              <b>VSSo</b> - generated concepts based on VSSo Core and the standard catalogue.
            </li>
            <li>
              <b>Extensions</b> - define how VSSo works together with other widely adopted standards (e.g. SSN/SOSA, IoTStream).
            </li> 
          </ul>
      <p></p>


      <section id="vsso-core">
        <h3 id="x3-1-vsso-core"><bdi class="secno">3.1 </bdi>VSSo Core<a class="self-link" href="#vsso-core" aria-label="Permalink for Section 3.1"></a></h3>
        <p align="justify">
          The core ontology introduces concepts for the structural elements of VSS defined through the rule set in the specifications.
          Figure 1 gives an overview of those. The root node is the Vehicle itself. From there the structure is given through so-called
          Branches. They serve as sorting element for the leaf nodes and are not specified in the specification itself in greater details.
          The leaf nodes contain the semantic information of signals, which expext to describe and hold information, which changes in
          greater frequency and of attributes, which are more static.
          
          The core of the ontology defines this structure in an OWL ontology and serves as a basis for the defined signals of the standard
          catalogue and potential further development of the branches as more than structural information.
        </p>
      </section>

      <section id="vsso">
        <h3 id="x3-2-vsso"><bdi class="secno">3.2 </bdi>VSSo<a class="self-link" href="#vsso" aria-label="Permalink for Section 3.2"></a></h3>
        <p align="justify">
          As the core ontology defined the structure, VSSo holds the vocabulary as defined by the standard catalogue.
          The main objective is, that VSSo doesn't diverege from the standard catalogue, so this is done automatically
          through tooling provided in the corresponding repository. The tooling takes the standard catalogue and maps it to
          concepts defined in the core ontology. The result is an OWL complient ontology, following the standard catalogue of VSS.
        </p>
      </section>

      <section id="extensions">
        <h3 id="x3-3-extensions"><bdi class="secno">3.3 </bdi>Extensions<a class="self-link" href="#extensions" aria-label="Permalink for Section 3.3"></a></h3>
        <p align="justify">
          VSSo Core and VSSo shall serve mainly as domain ontologies for data exchange and analysis. During the development of the
          ontologies one objective was to stay conceptionally close to SSN/SOSA.
        </p>
      </section>
      
      
    </section>
  

<p role="navigation" id="back-to-top">
    <a href="#title"><abbr title="Back to Top">↑</abbr></a>
  </p><script id="respec-dfn-panel">(() => {
// @ts-check
if (document.respec) {
  document.respec.ready.then(setupPanel);
} else {
  setupPanel();
}

function setupPanel() {
  const listener = panelListener();
  document.body.addEventListener("keydown", listener);
  document.body.addEventListener("click", listener);
}

function panelListener() {
  /** @type {HTMLElement} */
  let panel = null;
  return event => {
    const { target, type } = event;

    if (!(target instanceof HTMLElement)) return;

    // For keys, we only care about Enter key to activate the panel
    // otherwise it's activated via a click.
    if (type === "keydown" && event.key !== "Enter") return;

    const action = deriveAction(event);

    switch (action) {
      case "show": {
        hidePanel(panel);
        /** @type {HTMLElement} */
        const dfn = target.closest("dfn, .index-term");
        panel = document.getElementById(`dfn-panel-for-${dfn.id}`);
        const coords = deriveCoordinates(event);
        displayPanel(dfn, panel, coords);
        break;
      }
      case "dock": {
        panel.style.left = null;
        panel.style.top = null;
        panel.classList.add("docked");
        break;
      }
      case "hide": {
        hidePanel(panel);
        panel = null;
        break;
      }
    }
  };
}

/**
 * @param {MouseEvent|KeyboardEvent} event
 */
function deriveCoordinates(event) {
  const target = /** @type HTMLElement */ (event.target);

  // We prevent synthetic AT clicks from putting
  // the dialog in a weird place. The AT events sometimes
  // lack coordinates, so they have clientX/Y = 0
  const rect = target.getBoundingClientRect();
  if (
    event instanceof MouseEvent &&
    event.clientX >= rect.left &&
    event.clientY >= rect.top
  ) {
    // The event probably happened inside the bounding rect...
    return { x: event.clientX, y: event.clientY };
  }

  // Offset to the middle of the element
  const x = rect.x + rect.width / 2;
  // Placed at the bottom of the element
  const y = rect.y + rect.height;
  return { x, y };
}

/**
 * @param {Event} event
 */
function deriveAction(event) {
  const target = /** @type {HTMLElement} */ (event.target);
  const hitALink = !!target.closest("a");
  if (target.closest("dfn:not([data-cite]), .index-term")) {
    return hitALink ? "none" : "show";
  }
  if (target.closest(".dfn-panel")) {
    if (hitALink) {
      return target.classList.contains("self-link") ? "hide" : "dock";
    }
    const panel = target.closest(".dfn-panel");
    return panel.classList.contains("docked") ? "hide" : "none";
  }
  if (document.querySelector(".dfn-panel:not([hidden])")) {
    return "hide";
  }
  return "none";
}

/**
 * @param {HTMLElement} dfn
 * @param {HTMLElement} panel
 * @param {{ x: number, y: number }} clickPosition
 */
function displayPanel(dfn, panel, { x, y }) {
  panel.hidden = false;
  // distance (px) between edge of panel and the pointing triangle (caret)
  const MARGIN = 20;

  const dfnRects = dfn.getClientRects();
  // Find the `top` offset when the `dfn` can be spread across multiple lines
  let closestTop = 0;
  let minDiff = Infinity;
  for (const rect of dfnRects) {
    const { top, bottom } = rect;
    const diffFromClickY = Math.abs((top + bottom) / 2 - y);
    if (diffFromClickY < minDiff) {
      minDiff = diffFromClickY;
      closestTop = top;
    }
  }

  const top = window.scrollY + closestTop + dfnRects[0].height;
  const left = x - MARGIN;
  panel.style.left = `${left}px`;
  panel.style.top = `${top}px`;

  // Find if the panel is flowing out of the window
  const panelRect = panel.getBoundingClientRect();
  const SCREEN_WIDTH = Math.min(window.innerWidth, window.screen.width);
  if (panelRect.right > SCREEN_WIDTH) {
    const newLeft = Math.max(MARGIN, x + MARGIN - panelRect.width);
    const newCaretOffset = left - newLeft;
    panel.style.left = `${newLeft}px`;
    /** @type {HTMLElement} */
    const caret = panel.querySelector(".caret");
    caret.style.left = `${newCaretOffset}px`;
  }

  // As it's a dialog, we trap focus.
  // TODO: when <dialog> becomes a implemented, we should really
  // use that.
  trapFocus(panel, dfn);
}

/**
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function trapFocus(panel, dfn) {
  /** @type NodeListOf<HTMLAnchorElement> elements */
  const anchors = panel.querySelectorAll("a[href]");
  // No need to trap focus
  if (!anchors.length) return;

  // Move focus to first anchor element
  const first = anchors.item(0);
  first.focus();

  const trapListener = createTrapListener(anchors, panel, dfn);
  panel.addEventListener("keydown", trapListener);

  // Hiding the panel releases the trap
  const mo = new MutationObserver(records => {
    const [record] = records;
    const target = /** @type HTMLElement */ (record.target);
    if (target.hidden) {
      panel.removeEventListener("keydown", trapListener);
      mo.disconnect();
    }
  });
  mo.observe(panel, { attributes: true, attributeFilter: ["hidden"] });
}

/**
 *
 * @param {NodeListOf<HTMLAnchorElement>} anchors
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function createTrapListener(anchors, panel, dfn) {
  const lastIndex = anchors.length - 1;
  let currentIndex = 0;
  return event => {
    switch (event.key) {
      // Hitting "Tab" traps us in a nice loop around elements.
      case "Tab": {
        event.preventDefault();
        currentIndex += event.shiftKey ? -1 : +1;
        if (currentIndex < 0) {
          currentIndex = lastIndex;
        } else if (currentIndex > lastIndex) {
          currentIndex = 0;
        }
        anchors.item(currentIndex).focus();
        break;
      }

      // Hitting "Enter" on an anchor releases the trap.
      case "Enter":
        hidePanel(panel);
        break;

      // Hitting "Escape" returns focus to dfn.
      case "Escape":
        hidePanel(panel);
        dfn.focus();
        return;
    }
  };
}

/** @param {HTMLElement} panel */
function hidePanel(panel) {
  if (!panel) return;
  panel.hidden = true;
  panel.classList.remove("docked");
}
})()</script><script src="https://www.w3.org/scripts/TR/2021/fixup.js"></script></body></html>